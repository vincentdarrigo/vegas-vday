<!DOCTYPE html>
<html>
<head>
    <title>Vegas Valentine</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000;
            font-family: 'Courier Prime', monospace;
            color: white;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        /* --- SCREENS --- */
        #startScreen, #introScreen, #gameScreen, #gameOverScreen, #winnerScreen, #hugScreen, #slotScreen, #videoScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        }

        /* --- START SCREEN --- */
        #startScreen {
            background: url('gameboard.png') no-repeat center center;
            background-size: cover; 
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 100;
        }
        
        .start-overlay {
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 20px;
            border: 4px solid #ff00ff;
            box-shadow: 0 0 30px #ff00ff;
            text-align: center;
            max-width: 90%;
        }

        .title {
            font-size: 50px; color: #ff00ff; text-shadow: 0 0 15px #ff00ff;
            margin-bottom: 20px; text-transform: uppercase;
            animation: pulseTitle 2s infinite;
        }
        @keyframes pulseTitle { 50% { text-shadow: 0 0 30px #ff00ff; transform: scale(1.02); } }

        button {
            background: #ff00ff; color: white; font-size: 24px; padding: 15px 40px;
            border: 3px solid white; border-radius: 40px; cursor: pointer;
            box-shadow: 0 0 15px #ff00ff; font-weight: bold; margin-top: 15px;
            text-transform: uppercase;
            font-family: 'Courier Prime', monospace;
            touch-action: manipulation;
        }
        button:active { transform: scale(0.95); background: #fff; color: #ff00ff; }

        /* --- CRAWL TEXT --- */
        #introScreen, #gameOverScreen {
            display: none; background: black; z-index: 90;
            perspective: 500px; overflow: hidden;
        }

        .crawl-text {
            position: absolute; top: 100%; left: 5%; width: 90%;
            font-weight: bold; text-align: center; 
            transform-origin: 50% 100%;
            transform: rotateX(25deg);
            line-height: 1.5;
        }
        
        .intro-crawl {
            color: #ffd700; font-size: 24px; text-shadow: 0 0 10px #ff0000;
            animation: crawlAnim 25s linear forwards;
        }
        
        .outro-crawl {
            color: #ff69b4; 
            font-size: 36px; 
            text-shadow: 0 0 10px #ff00ff;
            animation: crawlAnim 25s linear forwards; 
            line-height: 1.8;
        }

        @keyframes crawlAnim { 
            0% { top: 110%; opacity: 1; } 
            95% { opacity: 1; } 
            100% { top: -200%; opacity: 0; } 
        }

        /* --- GAME SCREEN --- */
        #gameScreen {
            display: none;
            background: #000; 
        }

        /* HUD */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 10px 20px; box-sizing: border-box;
            display: flex; justify-content: space-between; align-items: flex-start;
            font-size: 24px; font-weight: bold; color: #fff;
            text-shadow: 2px 2px 0 #000; pointer-events: none; z-index: 10;
        }
        .stat-box { background: rgba(0,0,0,0.6); padding: 5px 10px; border-radius: 8px; border: 1px solid #ff00ff; margin-bottom: 5px; }

        /* END GAME BTN */
        #endGameBtn {
            position: absolute; top: 10px; right: 20px;
            background: #ff0000; border: 2px solid white;
            font-size: 16px; padding: 10px 15px;
            z-index: 100; pointer-events: auto;
            cursor: pointer;
            box-shadow: 0 0 10px red;
        }

        /* MINIMAP */
        #minimapContainer {
            position: absolute; bottom: 20px; left: 20px;
            border: 3px solid #ff00ff;
            background: rgba(0, 0, 0, 0.9);
            box-shadow: 0 0 10px #ff00ff;
            z-index: 100;
            border-radius: 5px;
            display: flex;
        }
        #minimap { width: 150px; height: 165px; display: block; }

        /* N64 JOYSTICK */
        #joystickZone {
            position: absolute; bottom: 30px; right: 30px;
            width: 150px; height: 150px;
            background: rgba(200, 200, 200, 0.3);
            border-radius: 50%;
            border: 4px solid #888;
            box-shadow: inset 0 0 20px #000;
            z-index: 100;
            touch-action: none;
        }
        #joystickStick {
            position: absolute; top: 50%; left: 50%;
            width: 60px; height: 60px;
            background: radial-gradient(circle at 30% 30%, #ddd, #888);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            pointer-events: none;
        }

        /* CANVAS */
        #gameCanvas { display: block; background: #000; touch-action: none; }

        /* --- SLOT MACHINE --- */
        #slotScreen {
            display: none;
            background: rgba(0,0,0,0.9);
            z-index: 300;
            flex-direction: column;
            align-items: center; justify-content: center;
        }
        .slot-machine {
            background: #333;
            border: 10px solid #ffd700;
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 0 50px #ffd700;
        }
        .reels-container {
            display: flex; gap: 10px; margin-bottom: 20px;
        }
        .reel {
            width: 80px; height: 80px;
            background: white;
            border: 3px solid #000;
            display: flex; align-items: center; justify-content: center;
            font-size: 40px; /* Fallback */
            overflow: hidden;
        }
        .reel img { width: 100%; height: 100%; object-fit: contain; }

        /* --- VIDEO PLAYER --- */
        #videoScreen {
            display: none; background: black; z-index: 400;
            flex-direction: column; align-items: center; justify-content: center;
        }
        video { max-width: 100%; max-height: 80vh; }
        #closeVideoBtn {
            display: none; margin-top: 20px;
            background: red; border-color: white;
        }

        /* --- WINNER / HUG SCREEN --- */
        #hugScreen { display: none; background: black; z-index: 250; align-items: center; justify-content: center; }
        #hugImage { max-width: 90%; max-height: 80%; border: 5px solid #ff00ff; box-shadow: 0 0 50px #ff00ff; animation: pulseHug 1s infinite; }
        @keyframes pulseHug { 0%{transform:scale(1);} 50%{transform:scale(1.05);} 100%{transform:scale(1);} }

        #winnerScreen { display: none; background: black; z-index: 200; }
        #winnerCanvas { display: block; width: 100%; height: 100%; }
        #winnerOverlay { position: absolute; top: 5%; width: 100%; text-align: center; text-shadow: 2px 2px 4px #000; pointer-events: none; }
        #winnerButtons { position: absolute; bottom: 20px; width: 100%; text-align: center; pointer-events: auto; }
        .winner-title { font-size: 40px; color: #ffd700; text-shadow: 0 0 20px #ff0000; margin-bottom: 10px; animation: bounce 1s infinite; }
        @keyframes bounce { 0%, 100% {transform:translateY(0);} 50% {transform:translateY(-10px);} }

        /* --- GAME OVER / RECEIPT --- */
        #receiptContainer {
            position: absolute; bottom: -150%; left: 50%; transform: translateX(-50%);
            width: 320px; text-align: center; transition: bottom 2s cubic-bezier(0.19, 1, 0.22, 1);
            z-index: 210;
        }
        .stats-receipt {
            background: white; color: black; font-family: 'Courier New', monospace;
            padding: 20px; border-bottom: 5px dashed black; text-align: left;
            transform: rotate(-2deg); box-shadow: 0 0 50px rgba(255,255,255,0.3);
            font-size: 18px; margin-bottom: 20px;
        }
        .receipt-line { display: flex; justify-content: space-between; margin-bottom: 5px; }
        #skipCreditsBtn { position: absolute; bottom: 30px; right: 30px; z-index:220; background: #fff; color: #ff00ff; border: 2px solid #ff00ff; }

        /* WINNER VIDEO POPUP */
        #winnerVideoContainer {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 600px; height: 300px;
            display: none; z-index: 500; border: 3px solid #ffd700; background: black;
        }

    </style>
</head>
<body>

    <div id="startScreen">
        <div class="start-overlay">
            <h1 class="title">Vegas Valentine</h1>
            <label>Parlay Intensity: <span id="speedDisplay">Normal</span></label><br>
            <input type="range" id="speedInput" min="1" max="3" value="2" style="width: 200px; margin: 10px 0;">
            <div style="margin-top: 20px;">
                <h3>Top Scores</h3>
                <div id="highScores" style="font-size: 16px; color: #ffd700;">Loading...</div>
            </div>
            <button onclick="startIntro()">Start Run</button>
        </div>
    </div>

    <div id="introScreen">
        <div class="crawl-text intro-crawl">
            EPISODE I<br>THE VEGAS STRIP<br><br>
            Your mission is simple:<br><br>
            1. Find your bumbum as many times as you can.<br><br>
            2. Eat ALL the delicious food to clear the board.<br><br>
            WATCH OUT FOR PARLAYS:<br>
            They will cost you bigtime, sending you back to the start...hug your bumbum for temporary invincibility!<br><br>
            BEWARE SEAFOOD: <br> Eating it makes everyone mad around you!<br>Gift boxes contain more food but watch out for pranks!<br><br>
            Clear the board of pizza, pasta/meatballs, and steak/potatoes while hugging your bumbum as many times as possible when you see him appear!<br><br>
            Tap the seafood to make it disappear before it stinks up the whole city!
            Good Luck Bbbbyyyykins!
        </div>
        <button style="position: absolute; bottom: 30px; right: 30px; z-index:95;" onclick="startGame(1)">SKIP >></button>
    </div>

    <div id="hugScreen" style="display:none;">
        <img id="hugImage" src="hug.png" alt="HUG!">
    </div>

    <div id="slotScreen" style="display:none;">
        <div class="slot-machine">
            <h2 style="color: #ffd700; margin-top:0;">VEGAS SLOTS!</h2>
            <div class="reels-container">
                <div class="reel" id="reel1">?</div>
                <div class="reel" id="reel2">?</div>
                <div class="reel" id="reel3">?</div>
            </div>
            <div id="slotMessage" style="color: white; height: 30px; margin-bottom: 10px;"></div>
            <button id="spinBtn" onclick="spinSlots()">SPIN!</button>
            <button id="closeSlotBtn" onclick="closeSlots()" style="display:none; background: #666; font-size: 18px;">RETURN</button>
        </div>
    </div>

    <div id="videoScreen" style="display:none;">
        <video id="rewardVideo" playsinline></video>
        <button id="closeVideoBtn" onclick="closeVideo()">CLOSE VIDEO</button>
    </div>

    <div id="gameScreen">
        <div id="hud">
            <div>
                <div class="stat-box">SCORE: <span id="scoreVal">0</span></div>
                <div class="stat-box" style="color: #0ff;">FOOD LEFT: <span id="foodVal">0</span></div>
            </div>
            <div class="stat-box" style="color: #f0f;">LEVEL: <span id="levelVal">1</span></div>
        </div>
        
        <button id="endGameBtn" onclick="gameOver()">END GAME</button>
        
        <div id="minimapContainer">
            <canvas id="minimap" width="200" height="220"></canvas>
        </div>

        <div id="joystickZone">
            <div id="joystickStick"></div>
        </div>

        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="winnerScreen">
        <div id="winnerOverlay">
            <div class="winner-title">CONGRATULATIONS,<br>YOU DID IT!</div>
        </div>
        <div id="winnerVideoContainer">
            <video id="winnerVideo" style="width:100%; height:100%;" controls playsinline></video>
            <button onclick="document.getElementById('winnerVideoContainer').style.display='none'; document.getElementById('winnerVideo').pause();" style="position:absolute; top:-10px; right:-10px; padding:5px; font-size:12px;">X</button>
        </div>
        <canvas id="winnerCanvas"></canvas>
        <div id="winnerButtons">
            <button onclick="gameOver()">Receipt</button>
            <button id="nextLevelBtn" onclick="startNextLevel()" style="display:none; margin-left:20px; background:#ffd700; color:#000;">TRY LEVEL 2</button>
        </div>
    </div>

    <div id="gameOverScreen">
        <div class="crawl-text outro-crawl" id="outroText">
            Happy Valentine's Day<br>bbbbyyyy<br><br>
            I love you bumbum<br>
            ‚ù§Ô∏è üíò üíù üíñ<br><br>
            Sowwy that we couldn't be<br>
            in Vegas for this<br>
            Valentine's Day...<br><br>
            But I hope you enjoyed<br>
            a two dimensional<br>
            practice run!<br>
            üí∞ üé≤ üé∞ üçï<br><br>
            I love you oodles<br>
            and bunches<br>
            üòç
        </div>
        <button id="skipCreditsBtn" onclick="skipOutro()">SKIP CREDITS >></button>
        <div id="receiptContainer">
            <div class="stats-receipt">
                <h3 style="text-align: center; margin-top:0;">VEGAS RECEIPT</h3>
                <hr>
                <div class="receipt-line"><span>Pizza Eaten:</span> <span id="statPizza">0</span></div>
                <div class="receipt-line"><span>Pasta Eaten:</span> <span id="statPasta">0</span></div>
                <div class="receipt-line"><span>Potatoes:</span> <span id="statPotato">0</span></div>
                <div class="receipt-line"><span>Good Boxes:</span> <span id="statBox">0</span></div>
                <hr>
                <div class="receipt-line"><span>Bazingas!:</span> <span id="statSheldon">0</span></div>
                <div class="receipt-line"><span>Ramsay Yells:</span> <span id="statRamsay">0</span></div>
                <hr>
                <div class="receipt-line" style="font-weight:bold; font-size:20px;"><span>HUGS (BUMBUM):</span> <span id="statHugs">0</span></div>
                <hr>
                <div style="font-size: 22px; text-align: center; margin-top: 10px;">
                    TOTAL SCORE<br>
                    <span id="finalScore" style="font-weight:bold;">0</span>
                </div>
            </div>
            <button onclick="location.reload()">PLAY AGAIN</button>
        </div>
    </div>

<script>
    // --- CONFIGURATION ---
    const TILE = 125; 
    const ANIM_SPEED = 8; 
    const BLOCKER_DURATION = 5000; 
    const HUSBAND_SCORE_THRESHOLD = 500; 

    // ASSETS
    const ASSET_NAMES = ['wife3', 'idle', 'husband', 'cupid1', 'cupid2', 'parlay', 'ramsay', 'sheldon', 'pizza', 'pasta', 'potato', 'shrimp', 'box', 'hug', 'vegas', 'winner', 'slots'];
    const AUDIO_NAMES = ['hangover', 'ramsay', 'bazinga', 'loveyoubumbum', 'chaching', 'endgame', 'splat'];
    const VIDEO_PLAYLIST = [
        'if-youre-into-it.mp4',
        'most-beautiful-girl.mp4',
        'parmesan.mp4',
        'rhymenocerous.mp4',
        'business-time.mp4',
        'boom.mp4'
    ];
    let availableVideos = [...VIDEO_PLAYLIST];

    // Map: 1=Wall, 0=Food, 2=Box, 3=Slots, 9=Empty, 5=GhostSpawn, 'P'=Player
    const BASE_MAP = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
        [1,2,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,2,1],
        [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
        [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
        [1,1,1,1,0,1,1,1,9,1,9,1,1,1,0,1,1,1,1],
        [1,1,1,1,0,1,9,9,9,5,9,9,9,1,0,1,1,1,1], 
        [1,1,1,1,0,1,9,1,1,9,1,1,9,1,0,1,1,1,1],
        [1,0,0,0,0,0,0,1,9,9,9,1,0,0,0,0,0,0,1],
        [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
        [1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,1],
        [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
        [1,0,0,0,0,0,0,0,0,'P',0,0,0,0,0,0,0,0,1],
        [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
        [1,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    let MAP = []; 
    const ROWS = BASE_MAP.length;
    const COLS = BASE_MAP[0].length;
    const WORLD_WIDTH = COLS * TILE;
    const WORLD_HEIGHT = ROWS * TILE;

    const IMAGES = {};
    const AUDIO = {};
    
    // GAME STATE
    let currentLevel = 1;
    let canvas, ctx, miniCanvas, miniCtx;
    let gameLoop;
    let score = 0;
    let frameCount = 0;
    let parlaySpeedBase = 3; 
    let camera = { x: 0, y: 0 };
    let isInvincible = false;
    let invincibleTimer = 0;
    let totalFood = 0;
    let stats = { pizza:0, pasta:0, potato:0, box:0, sheldon:0, ramsay:0, hugs:0 };
    let blockers = []; 
    let keys = { Up: false, Down: false, Left: false, Right: false };
    let player = { x:0, y:0, c:0, r:0, animFrame: 0, facingLeft: false };
    let ghosts = [];
    let items = [];
    let popups = [];
    let gamePaused = false;
    let gameWon = false;

    // HUSBAND AI
    let husband = { 
        active: false, x:0, y:0, timer:0, lastScore: 0, vx:0, vy:0, state: 'FLYING'
    };

    // WINNER ANIMATION
    let winAnim = { wifeX: -150, husbX: 0, groundY: 0, items: [], spawnTimer: 0, state: 'RUN_TO_HUG', kickTimer: 0 };

    window.onload = function() {
        loadAssets();
        loadScores();
        initJoystick();

        // Keyboard Support (Backup)
        window.addEventListener('keydown', e => {
            if(['ArrowUp','w'].includes(e.key)) keys.Up = true;
            if(['ArrowDown','s'].includes(e.key)) keys.Down = true;
            if(['ArrowLeft','a'].includes(e.key)) keys.Left = true;
            if(['ArrowRight','d'].includes(e.key)) keys.Right = true;
        });
        window.addEventListener('keyup', e => {
            if(['ArrowUp','w'].includes(e.key)) keys.Up = false;
            if(['ArrowDown','s'].includes(e.key)) keys.Down = false;
            if(['ArrowLeft','a'].includes(e.key)) keys.Left = false;
            if(['ArrowRight','d'].includes(e.key)) keys.Right = false;
        });

        document.getElementById('speedInput').oninput = function() {
            const labels = ["Slow", "Normal", "Fast"];
            document.getElementById('speedDisplay').innerText = labels[this.value-1];
            parlaySpeedBase = [3, 5, 8][this.value-1];
        };

        // Prevent accidental zooming
        document.addEventListener('touchmove', function(event) { if (event.scale !== 1) event.preventDefault(); }, { passive: false });
        document.addEventListener('dblclick', function(event) { event.preventDefault(); }, { passive: false });
        
        // Winner Canvas Tap
        document.getElementById('winnerCanvas').addEventListener('click', function(e) {
            if(winAnim.state === 'HUGGING') {
                let v = document.getElementById('winnerVideo');
                v.src = 'squareone.mp4';
                document.getElementById('winnerVideoContainer').style.display = 'block';
                v.play();
            }
        });
    };

    function loadAssets() {
        ASSET_NAMES.forEach(name => {
            const img = new Image();
            img.src = name + '.png';
            IMAGES[name] = img;
        });
        AUDIO_NAMES.forEach(name => {
            AUDIO[name] = new Audio(name + '.mp3');
        });
        if(AUDIO.hangover) { AUDIO.hangover.loop = true; AUDIO.hangover.volume = 0.4; }
        if(AUDIO.chaching) AUDIO.chaching.volume = 0.6;
        if(AUDIO.splat) AUDIO.splat.volume = 0.8;
        if(AUDIO.endgame) AUDIO.endgame.loop = true; 
    }

    // --- JOYSTICK LOGIC ---
    function initJoystick() {
        const zone = document.getElementById('joystickZone');
        const stick = document.getElementById('joystickStick');
        let startX, startY;
        
        zone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            stick.style.transition = 'none';
        }, {passive:false});

        zone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            let deltaX = touch.clientX - startX;
            let deltaY = touch.clientY - startY;
            const dist = Math.sqrt(deltaX**2 + deltaY**2);
            const maxDist = 45; 
            
            if(dist > maxDist) {
                const angle = Math.atan2(deltaY, deltaX);
                deltaX = Math.cos(angle) * maxDist;
                deltaY = Math.sin(angle) * maxDist;
            }
            
            stick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            
            // Map to Keys
            keys.Up = deltaY < -20;
            keys.Down = deltaY > 20;
            keys.Left = deltaX < -20;
            keys.Right = deltaX > 20;
        }, {passive:false});

        zone.addEventListener('touchend', (e) => {
            e.preventDefault();
            stick.style.transform = `translate(-50%, -50%)`;
            keys.Up = false; keys.Down = false; keys.Left = false; keys.Right = false;
        }, {passive:false});
    }

    function startIntro() {
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('introScreen').style.display = 'block';
        if(AUDIO.endgame) { AUDIO.endgame.currentTime = 0; AUDIO.endgame.play().catch(e => console.log("Click required")); }
        setTimeout(() => { if(document.getElementById('introScreen').style.display === 'block') startGame(1); }, 22000);
    }

    function startGame(lvl) {
        currentLevel = lvl;
        document.getElementById('levelVal').innerText = currentLevel;
        document.getElementById('introScreen').style.display = 'none';
        document.getElementById('gameScreen').style.display = 'block';
        document.getElementById('winnerScreen').style.display = 'none';
        
        if(AUDIO.endgame) AUDIO.endgame.pause();
        if(AUDIO.hangover) { AUDIO.hangover.currentTime = 0; AUDIO.hangover.play(); }

        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Tap Listener for Shrimp
        canvas.addEventListener('mousedown', handleCanvasTap);
        canvas.addEventListener('touchstart', handleCanvasTap, {passive: false});

        miniCanvas = document.getElementById('minimap');
        miniCtx = miniCanvas.getContext('2d');
        
        resetLevel();
        gameWon = false;
        gamePaused = false;
        gameLoop = requestAnimationFrame(update);
    }

    function startNextLevel() {
        startGame(2);
    }

    function handleCanvasTap(e) {
        if(gamePaused || gameWon) return;
        e.preventDefault();
        let cx = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        let cy = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
        
        let gameX = cx + camera.x;
        let gameY = cy + camera.y;
        let c = Math.floor(gameX / TILE);
        let r = Math.floor(gameY / TILE);
        
        let idx = items.findIndex(i => i.type === 'shrimp' && i.c === c && i.r === r);
        if(idx !== -1) {
            items.splice(idx, 1);
            if(AUDIO.splat) { let s = AUDIO.splat.cloneNode(); s.volume = 0.6; s.play().catch(e=>{}); }
        }
    }

    function resetLevel() {
        items = []; ghosts = []; blockers = []; popups = [];
        MAP = JSON.parse(JSON.stringify(BASE_MAP)); 
        
        // Reset score only on Level 1
        if(currentLevel === 1) {
            score = 0;
            stats = { pizza:0, pasta:0, potato:0, box:0, sheldon:0, ramsay:0, hugs:0 };
        }
        totalFood = 0;
        
        // 1. Prepare Box Rewards Deck (Shuffle)
        let rewardDeck = ['pizza', 'pasta', 'potato', 'shrimp'];
        // Fill deck with more random items
        for(let i=0; i<10; i++) rewardDeck.push(['pizza','pasta','potato','shrimp'][Math.floor(Math.random()*4)]);
        rewardDeck.sort(() => Math.random() - 0.5);

        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                let cell = MAP[r][c];
                let x = c*TILE + TILE/2;
                let y = r*TILE + TILE/2;
                
                if(cell === 0) {
                    // Randomly convert 5% of food to Mystery Boxes
                    if(Math.random() < 0.05) {
                        cell = 2; // Treat as box now
                    } else {
                        if(Math.random() < 0.15) items.push({c, r, type: 'shrimp', val:0});
                        else {
                            let foodType = Math.random() > 0.6 ? 'pizza' : (Math.random() > 0.5 ? 'pasta' : 'potato');
                            items.push({c, r, type: foodType, val:100});
                            totalFood++;
                        }
                        if(Math.random() < 0.03) items.push({c,r, type:'slots', val:0});
                    }
                }
                
                // BOX LOGIC (Includes converted cells)
                if(cell === 2) {
                    let reward = rewardDeck.length > 0 ? rewardDeck.pop() : 'pizza';
                    items.push({c, r, type:'box', val:0, rewardType: reward});
                }
                
                if(cell === 'P') { player.x = x; player.y = y; player.c = c; player.r = r; MAP[r][c] = 0; }
                if(cell === 5) {
                    for(let i=0; i<4; i++) ghosts.push({ x:x, y:y, vx:0, vy:0, speed:parlaySpeedBase });
                }
            }
        }
        
        if(!items.some(i => i.type === 'slots')) {
             items.push({c:1, r:1, type:'slots', val:0});
        }
    }

    function update() {
        if(document.getElementById('gameScreen').style.display === 'none') return;
        if(gamePaused) { gameLoop = requestAnimationFrame(update); return; }

        if(isInvincible) {
            invincibleTimer--;
            if(invincibleTimer <= 0) isInvincible = false;
        }

        updateBlockers();
        movePlayer();
        moveGhosts();
        handleHusband();
        updateCamera();
        checkCollisions();
        draw();
        drawMinimap();
        
        document.getElementById('foodVal').innerText = totalFood;
        document.getElementById('scoreVal').innerText = score;
        frameCount++;
        
        if(!gameWon) gameLoop = requestAnimationFrame(update);
    }

    function updateBlockers() {
        let now = Date.now();
        for(let i = blockers.length - 1; i >= 0; i--) {
            let b = blockers[i];
            if(now > b.expires) { MAP[b.r][b.c] = 9; blockers.splice(i, 1); }
        }
    }

    function movePlayer() {
        const speed = 14; 
        let intendedDx = 0, intendedDy = 0;
        if(keys.Up) intendedDy = -speed;
        if(keys.Down) intendedDy = speed;
        if(keys.Left) intendedDx = -speed;
        if(keys.Right) intendedDx = speed;

        if(intendedDx === 0 && intendedDy !== 0) {
            let centerX = player.c * TILE + TILE/2;
            if(Math.abs(player.x - centerX) < 48) player.x = centerX;
        }
        if(intendedDy === 0 && intendedDx !== 0) {
            let centerY = player.r * TILE + TILE/2;
            if(Math.abs(player.y - centerY) < 48) player.y = centerY;
        }

        let dx = intendedDx, dy = intendedDy;
        if(dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }

        if(dx !== 0 || dy !== 0) {
            let margin = TILE * 0.35; 
            if(!checkWallCollision(player.x + dx, player.y, margin)) player.x += dx;
            if(!checkWallCollision(player.x, player.y + dy, margin)) player.y += dy;

            if(frameCount % ANIM_SPEED === 0) player.animFrame++;
            if(dx < 0) player.facingLeft = true;
            if(dx > 0) player.facingLeft = false;
        } else {
            player.animFrame = 0;
        }
        player.c = Math.floor(player.x / TILE);
        player.r = Math.floor(player.y / TILE);
    }

    function checkWallCollision(px, py, radius) {
        let points = [
            {c: Math.floor((px - radius)/TILE), r: Math.floor((py - radius)/TILE)},
            {c: Math.floor((px + radius)/TILE), r: Math.floor((py - radius)/TILE)},
            {c: Math.floor((px - radius)/TILE), r: Math.floor((py + radius)/TILE)},
            {c: Math.floor((px + radius)/TILE), r: Math.floor((py + radius)/TILE)}
        ];
        for(let p of points) {
            if(p.r < 0 || p.r >= ROWS || p.c < 0 || p.c >= COLS) return true;
            if(MAP[p.r][p.c] === 1 || MAP[p.r][p.c] === 8) return true;
        }
        return false;
    }

    function spawnBlocker(type, c, r, duration) {
        MAP[r][c] = 8; // Set Wall
        let dur = duration || BLOCKER_DURATION;
        blockers.push({ type: type, c: c, r: r, expires: Date.now() + dur });
        
        let neighbors = [
            {c: c+1, r: r}, {c: c-1, r: r}, {c: c, r: r+1}, {c: c, r: r-1}
        ];
        let best = null;
        let minDist = 999999;
        neighbors.forEach(n => {
            if(n.c >= 0 && n.c < COLS && n.r >= 0 && n.r < ROWS) {
                if(MAP[n.r][n.c] !== 1 && MAP[n.r][n.c] !== 8) {
                      let nx = n.c * TILE + TILE/2;
                      let ny = n.r * TILE + TILE/2;
                      let d = Math.sqrt((player.x - nx)**2 + (player.y - ny)**2);
                      if(d < minDist) { minDist = d; best = {x: nx, y: ny}; }
                }
            }
        });
        if(best) { player.x = best.x; player.y = best.y; }
    }

    function moveGhosts() {
        ghosts.forEach(g => {
            let gc = Math.floor(g.x / TILE);
            let gr = Math.floor(g.y / TILE);
            let centerX = gc*TILE + TILE/2;
            let centerY = gr*TILE + TILE/2;
            g.x += g.vx; g.y += g.vy;
            
            let dist = Math.sqrt((g.x-centerX)**2 + (g.y-centerY)**2);
            if(dist < g.speed || (g.vx===0 && g.vy===0)) {
                g.x = centerX; g.y = centerY;
                let opts = [];
                if(!isWall(gc+1, gr)) opts.push({x:1, y:0});
                if(!isWall(gc-1, gr)) opts.push({x:-1, y:0});
                if(!isWall(gc, gr+1)) opts.push({x:0, y:1});
                if(!isWall(gc, gr-1)) opts.push({x:0, y:-1});

                let pDist = Math.abs(player.c - gc) + Math.abs(player.r - gr);
                if(pDist < 7 && Math.random() > 0.2) {
                    let bestDir = null; let minD = 9999;
                    opts.sort(() => Math.random() - 0.5);
                    opts.forEach(d => {
                        let nc = gc + d.x; let nr = gr + d.y;
                        let dd = Math.abs(player.c - nc) + Math.abs(player.r - nr);
                        if(dd < minD) { minD = dd; bestDir = d; }
                    });
                    if(bestDir) { g.vx = bestDir.x * g.speed; g.vy = bestDir.y * g.speed; }
                    else if(opts.length > 0) { let d = opts[0]; g.vx = d.x * g.speed; g.vy = d.y * g.speed; }
                } else {
                    if(opts.length > 0) {
                        let forwardOpts = opts.filter(o => o.x !== -Math.sign(g.vx) || o.y !== -Math.sign(g.vy));
                        let d = forwardOpts.length > 0 ? forwardOpts[Math.floor(Math.random()*forwardOpts.length)] : opts[Math.floor(Math.random()*opts.length)];
                        g.vx = d.x * g.speed; g.vy = d.y * g.speed;
                    } else { g.vx = -g.vx; g.vy = -g.vy; }
                }
            }
        });
    }

    function isWall(c, r) {
        if(c < 0 || c >= COLS || r < 0 || r >= ROWS) return true;
        return MAP[r][c] === 1 || MAP[r][c] === 8;
    }

    function checkCollisions() {
        let iIdx = items.findIndex(i => i.c === player.c && i.r === player.r);
        if(iIdx !== -1) {
            let item = items[iIdx];
            if(item.type === 'shrimp') {
                stats.ramsay++;
                if(AUDIO.ramsay) AUDIO.ramsay.play();
                spawnBlocker('ramsay', item.c, item.r); 
                items.splice(iIdx, 1);
            }
            else if(item.type === 'box') {
                let reward = item.rewardType;
                
                if(reward === 'shrimp') {
                    // BAD BOX
                    stats.sheldon++;
                    if(AUDIO.bazinga) AUDIO.bazinga.play();
                    spawnBlocker('sheldon', item.c, item.r, 10000); // 10 Sec Sheldon
                    popups.push({ type: 'shrimp', x: 0, y: 0, scale: 0.1, opacity: 1.0 }); // Zoom Shrimp
                } 
                else {
                    // GOOD BOX
                    score += 500; stats.box++;
                    isInvincible = true; invincibleTimer = 600; 
                    if(AUDIO.chaching) AUDIO.chaching.play(); 
                    // Visual popup of whatever food it was
                    popups.push({ type: reward, x: 0, y: 0, scale: 0.1, opacity: 1.0 });
                }
                
                items.splice(iIdx, 1);
            } 
            else if(item.type === 'slots') {
                gamePaused = true;
                openSlots();
                items.splice(iIdx, 1);
            }
            else {
                score += item.val;
                if(item.type === 'pizza') stats.pizza++;
                if(item.type === 'pasta') stats.pasta++;
                if(item.type === 'potato') stats.potato++;
                totalFood--;
                items.splice(iIdx, 1);
            }
        }
        
        let playerHit = false;
        ghosts.forEach(g => {
            let d = Math.sqrt((player.x-g.x)**2 + (player.y-g.y)**2);
            if(d < TILE * 0.6) {
                if(isInvincible) {
                    g.x = (COLS/2)*TILE; g.y = (ROWS/2)*TILE; 
                    score += 100;
                    if(AUDIO.chaching) { AUDIO.chaching.currentTime = 0; AUDIO.chaching.play(); }
                } else {
                    playerHit = true;
                }
            }
        });

        if(playerHit) {
             player.c = 9; player.r = 14;
             player.x = 9 * TILE + TILE/2; 
             player.y = 14 * TILE + TILE/2;
             
             let spawnX = 9 * TILE + TILE/2;
             let spawnY = 8 * TILE + TILE/2;
             ghosts.forEach(g => { g.x = spawnX; g.y = spawnY; g.vx = 0; g.vy = 0; });
        }

        if(totalFood <= 0 && !gameWon) {
            startWinnerScreen();
        }
    }

    function handleHusband() {
        if(score > 0 && score % HUSBAND_SCORE_THRESHOLD === 0 && !husband.active && score > husband.lastScore) {
            husband.lastScore = score; 
            let attempts = 0;
            do {
                husband.c = Math.floor(Math.random() * (COLS-2)) + 1;
                husband.r = Math.floor(Math.random() * (ROWS-2)) + 1;
                attempts++;
            } while(isWall(husband.c, husband.r) && attempts < 100);
            husband.x = husband.c * TILE + TILE/2;
            husband.y = husband.r * TILE + TILE/2;
            husband.active = true;
            
            // Level 2: Shorter active time?
            husband.timer = currentLevel === 2 ? 2000 : 1200; 
            
            husband.state = 'FLYING';
            husband.vx = (Math.random() > 0.5 ? 2 : -2);
            husband.vy = (Math.random() > 0.5 ? 2 : -2);
        }
        
        if(husband.active) {
            husband.timer--;
            
            // --- AI LOGIC ---
            if(husband.state === 'FLYING') {
                if(currentLevel === 2) {
                    // FLEE MODE
                    // Vector away from player
                    let dx = husband.x - player.x;
                    let dy = husband.y - player.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if(dist < 300) { // If close, run away
                        husband.vx = (dx / dist) * 4;
                        husband.vy = (dy / dist) * 4;
                    }
                }
                
                husband.x += husband.vx;
                husband.y += husband.vy;
                if(husband.x < 0 || husband.x > WORLD_WIDTH) husband.vx = -husband.vx;
                if(husband.y < 0 || husband.y > WORLD_HEIGHT) husband.vy = -husband.vy;
                
                // Land briefly logic
                let landChance = currentLevel === 2 ? 0.005 : 0.01;
                if(Math.random() < landChance) {
                     husband.state = 'IDLE';
                     husband.landTimer = currentLevel === 2 ? 60 : 100; // Shorter rest in lvl 2
                }
            } else {
                // IDLE
                husband.landTimer--;
                if(husband.landTimer <= 0) {
                     husband.state = 'FLYING';
                     husband.vx = (Math.random() - 0.5) * 6;
                     husband.vy = (Math.random() - 0.5) * 6;
                }
            }

            if(husband.timer <= 0) husband.active = false;
            
            let d = Math.sqrt((player.x-husband.x)**2 + (player.y-husband.y)**2);
            if(d < TILE) {
                // CAUGHT
                stats.hugs++;
                if(AUDIO.loveyoubumbum) AUDIO.loveyoubumbum.play();
                husband.active = false;
                gamePaused = true;
                document.getElementById('hugScreen').style.display = 'flex';
                setTimeout(() => {
                    document.getElementById('hugScreen').style.display = 'none';
                    gamePaused = false;
                    isInvincible = true; 
                    invincibleTimer = 600; 
                }, 3000); 
            }
        } else {
            if(score % HUSBAND_SCORE_THRESHOLD !== 0) husband.lastScore = 0;
        }
    }

    function updateCamera() {
        camera.x = player.x - canvas.width / 2;
        camera.y = player.y - canvas.height / 2;
        camera.x = Math.max(0, Math.min(camera.x, WORLD_WIDTH - canvas.width));
        camera.y = Math.max(0, Math.min(camera.y, WORLD_HEIGHT - canvas.height));
        if(WORLD_WIDTH < canvas.width) camera.x = -(canvas.width - WORLD_WIDTH)/2;
        if(WORLD_HEIGHT < canvas.height) camera.y = -(canvas.height - WORLD_HEIGHT)/2;
    }

    function draw() {
        ctx.clearRect(0,0,canvas.width, canvas.height);
        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        if(IMAGES.vegas) ctx.drawImage(IMAGES.vegas, 0, 0, WORLD_WIDTH, WORLD_HEIGHT);

        // WALLS
        ctx.lineWidth = 4;
        let time = Date.now() / 20; 
        ctx.beginPath();
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(MAP[r][c] === 1) {
                    let hue = (c * 10 + r * 10 + time) % 360;
                    ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                    ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
                    ctx.shadowBlur = 15;
                    ctx.strokeRect(c*TILE + 8, r*TILE + 8, TILE-16, TILE-16);
                    ctx.shadowBlur = 0;
                    ctx.closePath(); ctx.stroke(); ctx.beginPath(); 
                }
            }
        }

        items.forEach(i => {
            let img = IMAGES[i.type] || IMAGES.pizza;
            ctx.drawImage(img, i.c*TILE+15, i.r*TILE+15, TILE-30, TILE-30);
        });

        blockers.forEach(b => {
             let img = b.type === 'ramsay' ? IMAGES.ramsay : IMAGES.sheldon;
             let shake = Math.random() * 4 - 2;
             ctx.drawImage(img, b.c*TILE + shake, b.r*TILE + shake, TILE, TILE);
        });

        if(husband.active) {
            ctx.save();
            ctx.translate(husband.x, husband.y);
            
            if(husband.state === 'FLYING') {
                let scale = 1.3; 
                ctx.scale(scale, scale);
                if(husband.vx < 0) ctx.scale(-1, 1);
                let cImg = (Math.floor(Date.now()/100)%2===0) ? IMAGES.cupid1 : IMAGES.cupid2;
                if(!cImg || !cImg.complete) cImg = IMAGES.husband; 
                ctx.drawImage(cImg, -TILE/2, -TILE/2, TILE, TILE);
            } else {
                let scale = 1 + Math.sin(Date.now()/200)*0.1;
                ctx.scale(scale, scale);
                ctx.drawImage(IMAGES.husband, -TILE/2, -TILE/2, TILE, TILE);
            }
            ctx.restore();
        }

        ctx.save();
        ctx.translate(player.x, player.y);
        if(player.facingLeft) ctx.scale(-1, 1);
        let sprite = IMAGES.idle;
        if(keys.Up || keys.Down || keys.Left || keys.Right) {
             let frame = Math.floor(player.animFrame) % 2; 
             if(frame === 0) sprite = IMAGES.wife3;
             else sprite = IMAGES.idle;
        }
        if(isInvincible) {
            if(Math.floor(frameCount/5)%2===0) ctx.globalAlpha = 0.4;
            ctx.beginPath(); ctx.arc(0,0, TILE/1.5, 0, Math.PI*2);
            ctx.strokeStyle = "white"; ctx.stroke();
        }
        ctx.drawImage(sprite, -TILE/2, -TILE/2, TILE, TILE);
        ctx.restore();

        ghosts.forEach(g => {
            if(isInvincible) ctx.globalAlpha = 0.5;
            ctx.drawImage(IMAGES.parlay, g.x - TILE/2, g.y - TILE/2, TILE, TILE);
            ctx.globalAlpha = 1.0;
        });

        popups.forEach((p, idx) => {
            if(p.opacity > 0 && IMAGES[p.type]) {
                ctx.save();
                ctx.globalAlpha = p.opacity;
                ctx.translate(camera.x + window.innerWidth/2, camera.y + window.innerHeight/2);
                ctx.scale(p.scale * 3, p.scale * 3); 
                ctx.drawImage(IMAGES[p.type], -75, -75, 150, 150); 
                ctx.restore();
                p.scale += 0.05; 
                p.opacity -= 0.015; 
            } else {
                popups.splice(idx, 1);
            }
        });

        ctx.restore();
        
        document.getElementById('scoreVal').innerText = score;
    }

    function drawMinimap() {
        if(!miniCtx) return;
        const scaleX = miniCanvas.width / WORLD_WIDTH;
        const scaleY = miniCanvas.height / WORLD_HEIGHT;
        miniCtx.fillStyle = "rgba(0,0,0,0.5)";
        miniCtx.fillRect(0, 0, miniCanvas.width, miniCanvas.height);
        miniCtx.fillStyle = "#666";
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(MAP[r][c] === 1) miniCtx.fillRect(c*TILE*scaleX, r*TILE*scaleY, TILE*scaleX, TILE*scaleY);
            }
        }
        items.forEach(i => {
            if(i.type === 'box') { miniCtx.fillStyle = "#FFD700"; miniCtx.fillRect(i.c*TILE*scaleX, i.r*TILE*scaleY, TILE*scaleX, TILE*scaleY); }
            else if (i.type === 'slots') { miniCtx.fillStyle = "#F0F"; miniCtx.fillRect(i.c*TILE*scaleX, i.r*TILE*scaleY, 5, 5); } 
            else if (i.type !== 'shrimp') { miniCtx.fillStyle = "#0ff"; miniCtx.fillRect(i.c*TILE*scaleX, i.r*TILE*scaleY, 3, 3); }
        });
        miniCtx.fillStyle = "#00ff00"; miniCtx.beginPath(); miniCtx.arc(player.x*scaleX, player.y*scaleY, 3, 0, Math.PI*2); miniCtx.fill();
        miniCtx.fillStyle = "#ff0000"; ghosts.forEach(g => { miniCtx.beginPath(); miniCtx.arc(g.x*scaleX, g.y*scaleY, 2, 0, Math.PI*2); miniCtx.fill(); });
        if(husband.active) { miniCtx.fillStyle = "white"; miniCtx.fillRect((husband.x-TILE/2)*scaleX, (husband.y-TILE/2)*scaleY, TILE*scaleX, TILE*scaleY); }
    }

    // --- SLOT MACHINE LOGIC ---
    function openSlots() {
        document.getElementById('slotScreen').style.display = 'flex';
        document.getElementById('spinBtn').style.display = 'inline-block';
        document.getElementById('closeSlotBtn').style.display = 'none';
        document.getElementById('slotMessage').innerText = "";
        ['reel1','reel2','reel3'].forEach(id => document.getElementById(id).innerHTML = '?');
    }

    function spinSlots() {
        document.getElementById('spinBtn').style.display = 'none';
        const symbols = ['cupid1', 'pizza', 'pasta', 'shrimp', 'potato', 'husband'];
        
        let spins = 0;
        let interval = setInterval(() => {
            ['reel1','reel2','reel3'].forEach(id => {
                let randSym = symbols[Math.floor(Math.random()*symbols.length)];
                document.getElementById(id).innerHTML = `<img src="${randSym}.png">`;
            });
            spins++;
            if(spins > 20) {
                clearInterval(interval);
                finalizeSlots(symbols);
            }
        }, 100);
    }

    function finalizeSlots(symbols) {
        let r1 = symbols[Math.floor(Math.random()*symbols.length)];
        let r2 = symbols[Math.floor(Math.random()*symbols.length)];
        let r3 = symbols[Math.floor(Math.random()*symbols.length)];
        
        document.getElementById('reel1').innerHTML = `<img src="${r1}.png">`;
        document.getElementById('reel2').innerHTML = `<img src="${r2}.png">`;
        document.getElementById('reel3').innerHTML = `<img src="${r3}.png">`;
        
        // CHECK WINS
        let results = [r1, r2, r3];
        let msg = "";
        let win = false;
        let shrimpCount = results.filter(s => s === 'shrimp').length;
        let cupidCount = results.filter(s => s === 'cupid1' || s === 'husband').length;

        if(r1 === r2 && r2 === r3) {
            msg = "JACKPOT! 5000 POINTS!";
            score += 5000;
            if(AUDIO.chaching) AUDIO.chaching.play();
        } else if (cupidCount >= 2) {
            msg = "LOVE BIRDS! 2000 POINTS!";
            score += 2000;
            if(AUDIO.chaching) AUDIO.chaching.play();
        } else if (shrimpCount > 0) {
            // SHRIMP PENALTY
            setTimeout(() => {
                playRandomVideo();
            }, 1000);
            return; // Don't show Close button yet
        } else {
            msg = "Better luck next time!";
        }

        document.getElementById('slotMessage').innerText = msg;
        document.getElementById('closeSlotBtn').style.display = 'inline-block';
    }

    function closeSlots() {
        document.getElementById('slotScreen').style.display = 'none';
        gamePaused = false;
    }

    // --- VIDEO PENALTY LOGIC ---
    function playRandomVideo() {
        let vScreen = document.getElementById('videoScreen');
        let vid = document.getElementById('rewardVideo');
        let btn = document.getElementById('closeVideoBtn');
        
        vScreen.style.display = 'flex';
        btn.style.display = 'none'; // Lock
        
        // Pick random video no repeats
        if(availableVideos.length === 0) availableVideos = [...VIDEO_PLAYLIST];
        let rIdx = Math.floor(Math.random() * availableVideos.length);
        let vSrc = availableVideos[rIdx];
        availableVideos.splice(rIdx, 1);
        
        vid.src = vSrc;
        vid.play();

        // Unlock after 10s
        setTimeout(() => {
            btn.style.display = 'block';
        }, 10000);
    }

    function closeVideo() {
        let vid = document.getElementById('rewardVideo');
        vid.pause();
        document.getElementById('videoScreen').style.display = 'none';
        closeSlots(); // Return to game
    }

    // --- WINNER LOGIC ---
    function startWinnerScreen() {
        gameWon = true;
        document.getElementById('gameScreen').style.display = 'none';
        document.getElementById('winnerScreen').style.display = 'block';
        
        if(currentLevel === 1) document.getElementById('nextLevelBtn').style.display = 'inline-block';
        else document.getElementById('nextLevelBtn').style.display = 'none';

        let wc = document.getElementById('winnerCanvas');
        wc.width = window.innerWidth;
        wc.height = window.innerHeight;
        
        winAnim.groundY = wc.height * 0.85; 
        winAnim.wifeX = -200;
        winAnim.husbX = wc.width * 0.55; 
        winAnim.state = 'RUN_TO_HUG';
        winAnim.items = [];
        winAnim.spawnTimer = 0;
        
        requestAnimationFrame(updateWinnerAnim);
    }

    function updateWinnerAnim() {
        if(!gameWon) return;
        let wc = document.getElementById('winnerCanvas');
        let wCtx = wc.getContext('2d');
        
        wCtx.clearRect(0, 0, wc.width, wc.height);
        if(IMAGES.winner) { wCtx.drawImage(IMAGES.winner, 0, 0, wc.width, wc.height); }

        if(winAnim.state === 'RUN_TO_HUG') {
            winAnim.wifeX += 6; 
            if(winAnim.wifeX >= winAnim.husbX - 80) winAnim.state = 'HUGGING';
        }

        winAnim.spawnTimer++;
        if(winAnim.spawnTimer > 60 && Math.random() > 0.5) {
            winAnim.spawnTimer = 0;
            const creditTypes = ['pizza', 'pasta', 'potato', 'box', 'sheldon', 'ramsay', 'parlay', 'shrimp'];
            let type = creditTypes[Math.floor(Math.random()*creditTypes.length)];
            let isForeground = Math.random() > 0.5;
            let spawnY = isForeground ? winAnim.groundY + 20 : winAnim.groundY - 140; 
            
            winAnim.items.push({ type: type, x: -100, y: spawnY, vx: 4 + Math.random() * 2, kicked: false, vy: 0 });
        }

        let bgItems = winAnim.items.filter(i => i.y < winAnim.groundY);
        let fgItems = winAnim.items.filter(i => i.y >= winAnim.groundY);

        let drawItem = (item) => {
             item.x += item.vx;
             if(item.type === 'shrimp' && !item.kicked && winAnim.state !== 'RUN_TO_HUG') {
                 if(item.x > winAnim.husbX - 100 && item.x < winAnim.husbX + 50) {
                     winAnim.state = 'KICKING';
                     winAnim.kickTimer = 30; 
                     item.kicked = true;
                     item.vx = 15; item.vy = -15; 
                     if(AUDIO.splat) AUDIO.splat.play();
                 }
             }
             if(item.kicked) { item.y += item.vy; item.vy += 1; }
             if(IMAGES[item.type]) wCtx.drawImage(IMAGES[item.type], item.x, item.y, 75, 75);
        };

        bgItems.forEach(drawItem);

        let husbY = winAnim.groundY - 150;
        let wifeY = winAnim.groundY - 150;
        
        if(winAnim.state === 'HUGGING') {
            if(IMAGES.hug) wCtx.drawImage(IMAGES.hug, winAnim.husbX - 20, husbY, 160, 160);
        } 
        else if (winAnim.state === 'KICKING') {
            wCtx.drawImage(IMAGES.husband, winAnim.husbX + 30, husbY, 150, 150);
            wCtx.drawImage(IMAGES.wife3, winAnim.wifeX - 20, wifeY, 150, 150);
            winAnim.kickTimer--;
            if(winAnim.kickTimer <= 0) winAnim.state = 'HUGGING'; 
        }
        else {
            wCtx.drawImage(IMAGES.husband, winAnim.husbX, husbY, 150, 150);
            let wImg = (Math.floor(Date.now()/100)%2===0) ? IMAGES.wife3 : IMAGES.idle;
            wCtx.drawImage(wImg, winAnim.wifeX, wifeY, 150, 150);
        }

        fgItems.forEach(drawItem);
        requestAnimationFrame(updateWinnerAnim);
    }

    function gameOver() {
        saveScore(score);
        cancelAnimationFrame(gameLoop);
        gameWon = false; 
        if(AUDIO.hangover) AUDIO.hangover.pause();
        if(AUDIO.endgame) { AUDIO.endgame.currentTime = 0; AUDIO.endgame.play(); }

        document.getElementById('winnerScreen').style.display = 'none'; 
        document.getElementById('gameScreen').style.display = 'none';
        document.getElementById('gameOverScreen').style.display = 'block';
        document.getElementById('receiptContainer').style.bottom = "-150%";

        document.getElementById('statPizza').innerText = stats.pizza;
        document.getElementById('statPasta').innerText = stats.pasta;
        document.getElementById('statPotato').innerText = stats.potato;
        document.getElementById('statBox').innerText = stats.box;
        document.getElementById('statSheldon').innerText = stats.sheldon;
        document.getElementById('statRamsay').innerText = stats.ramsay;
        document.getElementById('statHugs').innerText = stats.hugs;
        document.getElementById('finalScore').innerText = score;

        setTimeout(() => {
            document.getElementById('receiptContainer').style.bottom = "50%";
            document.getElementById('receiptContainer').style.transform = "translate(-50%, 50%)";
        }, 2500); 
    }

    function skipOutro() {
        document.getElementById('outroText').style.display = 'none';
        document.getElementById('receiptContainer').style.transition = "none";
        document.getElementById('receiptContainer').style.bottom = "50%";
        document.getElementById('receiptContainer').style.transform = "translate(-50%, 50%)";
        document.getElementById('skipCreditsBtn').style.display = 'none';
    }

    function saveScore(s) {
        let sc = JSON.parse(localStorage.getItem('vegasScores') || "[]");
        sc.push({d: new Date().toLocaleDateString(), s:s});
        sc.sort((a,b) => b.s - a.s);
        localStorage.setItem('vegasScores', JSON.stringify(sc.slice(0,5)));
    }
    function loadScores() {
        let sc = JSON.parse(localStorage.getItem('vegasScores') || "[]");
        let html = sc.length ? "" : "No scores yet!";
        sc.forEach(x => html += `<div>${x.d}: ${x.s}</div>`);
        document.getElementById('highScores').innerHTML = html;
    }
</script>
</body>
</html>